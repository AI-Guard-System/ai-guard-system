{
  "version": 3,
  "sources": ["../src/security/EntropyScanner.ts", "../src/security/InjectionScanner.ts", "../src/security/PII.ts", "../src/AiGuardStream.ts", "../src/core/repair.js", "../src/core/scanner.js", "../src/core/registry.js", "../src/schema/SchemaEngine.js"],
  "sourcesContent": ["import { EntropyResult } from '../types';\n\n/**\n * Calculates the Shannon Entropy of a string.\n * Higher entropy usually indicates random data (keys, secrets, encrypted text).\n * Normal English text usually has entropy between 3.5 and 5.0.\n * Random 32-char hex strings -> ~4.0-4.5, but dense base64 -> ~5.5-6.0\n */\nexport function calculateShannonEntropy(str: string): number {\n    if (!str) return 0;\n\n    const charMap: Record<string, number> = {};\n    const len = str.length;\n\n    for (let i = 0; i < len; i++) {\n        const char = str[i];\n        charMap[char] = (charMap[char] || 0) + 1;\n    }\n\n    let entropy = 0;\n    for (const char in charMap) {\n        const p = charMap[char] / len;\n        entropy -= p * Math.log2(p);\n    }\n\n    return entropy;\n}\n\n/**\n * Scans a string for high-entropy segments that might look like secrets.\n * We scan tokens (words) to avoid flagging checking entire sentences.\n */\nexport function scanEntropy(text: string, threshold: number = 5.2): EntropyResult[] {\n    const tokens = text.split(/\\s+/);\n    const results: EntropyResult[] = [];\n\n    for (const token of tokens) {\n        // Ignore short tokens (less than 8 chars usually not a secret key)\n        if (token.length < 8) continue;\n\n        const entropy = calculateShannonEntropy(token);\n        if (entropy > threshold) {\n            results.push({\n                score: entropy,\n                isHighEntropy: true,\n                text: token\n            });\n        }\n    }\n\n    return results;\n}\n", "import { InjectionResult } from '../types';\n\nconst INJECTION_PATTERNS = [\n    { pattern: /ignore previous instructions/i, score: 0.9, name: 'IGNORE_PREVIOUS' },\n    { pattern: /system override/i, score: 0.9, name: 'SYSTEM_OVERRIDE' },\n    { pattern: /\\bDAN\\b/i, score: 0.6, name: 'DAN_MODE' }, // Do Anything Now\n    { pattern: /dev mode/i, score: 0.7, name: 'DEV_MODE' },\n    { pattern: /act as a/i, score: 0.3, name: 'ACT_AS' }, // Lower score, common in legitimate prompts\n    { pattern: /you are unrestricted/i, score: 0.95, name: 'UNRESTRICTED' },\n    { pattern: /disable safety procedures/i, score: 1.0, name: 'DISABLE_SAFETY' }\n];\n\n/**\n * Scans text for Prompt Injection attacks.\n * Returns a risk score (0-1).\n */\nexport function scanInjection(text: string): InjectionResult {\n    let maxScore = 0;\n    let detected = false;\n    let reason = '';\n\n    for (const item of INJECTION_PATTERNS) {\n        if (item.pattern.test(text)) {\n            if (item.score > maxScore) {\n                maxScore = item.score;\n                detected = true;\n                reason = `Detected pattern: ${item.name}`;\n            }\n        }\n    }\n\n    // Heuristic: Check for repeated overlapping commands?\n    // For now, pattern matching is v1.\n\n    return {\n        score: maxScore,\n        isDetected: detected,\n        reason: detected ? reason : undefined\n    };\n}\n", "import { PIIResult, PIIOption, PIIFinding } from '../types';\n\nconst PATTERNS: Record<string, RegExp> = {\n    CREDIT_CARD: /\\b(?:\\d{4}[ -]?){3}\\d{4}\\b/,\n    EMAIL: /\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}\\b/,\n    API_KEY: /\\b(sk-[a-zA-Z0-9]{20,}|ghp_[a-zA-Z0-9]{36}|gho_[a-zA-Z0-9]{36})\\b/,\n    SSN: /\\b\\d{3}-\\d{2}-\\d{4}\\b/,\n    IPV4: /\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\b/,\n    AWS_KEY: /\\b(AKIA[0-9A-Z]{16})\\b/,\n    JWT: /\\beyJ[a-zA-Z0-9_-]*\\.eyJ[a-zA-Z0-9_-]*\\.[a-zA-Z0-9_-]*\\b/\n};\n\n// Context keywords that increase confidence it is PII\nconst CONTEXT_TRIGGERS: Record<string, string[]> = {\n    SSN: ['ssn', 'social', 'security', 'number', 'id'],\n    CREDIT_CARD: ['cc', 'card', 'visa', 'amex', 'mastercard', 'payment'],\n    API_KEY: ['key', 'api', 'secret', 'token'],\n    EMAIL: ['email', 'contact', 'mail']\n};\n\n/**\n * Scans text for PII with Context Window.\n * Instead of blind regex, looks at preceding words.\n */\nexport function scanPII(text: string, options: PIIOption = {}): PIIResult {\n    const {\n        rules = Object.keys(PATTERNS),\n        redact = false,\n        allow = [],\n        mode = 'block'\n    } = options;\n\n    let cleanText = text;\n    const findings: PIIFinding[] = [];\n    let isClean = true;\n\n    const allowPatterns = allow.map(p =>\n        typeof p === 'string' ? new RegExp(p) : p\n    );\n\n    for (const ruleKey of rules) {\n        const regex = PATTERNS[ruleKey];\n        if (!regex) continue;\n\n        const globalRegex = new RegExp(regex.source, 'g');\n        let match: RegExpExecArray | null;\n\n        while ((match = globalRegex.exec(text)) !== null) {\n            const matchText = match[0];\n            const index = match.index;\n\n            // 1. Check Allow List\n            if (allowPatterns.some(ap => ap.test(matchText))) {\n                continue;\n            }\n\n            // 2. Context Window Check (Optional but recommended for strictness)\n            // Extract preceding 20 chars\n            const start = Math.max(0, index - 25);\n            const prefix = text.slice(start, index).toLowerCase();\n\n            // If we have context triggers for this rule, check them.\n            // If valid PII regex matches, valid PII is usually independent of context, \n            // BUT for things like \"123-45\", context helps.\n            // Current regexes are fairly specific (SSN is 3-2-4).\n            // However, per prompt: \"check preceding words to confirm if '123-45' is actually PII\"\n            // If the regex matches a generic format, we can check context. \n            // For now, we'll mark context as 'found' or 'missing'. \n            // The prompt says \"Fixing regex false-positive issue\".\n\n            // Heuristic: If it looks like PII, we count it. \n            // Context logic:\n            let contextScore = 0;\n            const triggers = CONTEXT_TRIGGERS[ruleKey] || [];\n            if (triggers.length > 0) {\n                if (triggers.some(t => prefix.includes(t))) {\n                    contextScore = 1; // High confidence\n                }\n            }\n\n            // We add it to findings.\n            findings.push({\n                type: ruleKey,\n                match: matchText,\n                context: contextScore > 0 ? 'supported' : 'neutral'\n            });\n\n            isClean = false;\n        }\n    }\n\n    // Redaction Logic\n    if (!isClean && (redact || mode === 'block')) {\n        // Replace unique matches to avoid double work\n        const uniqueMatches = [...new Set(findings.map(f => f.match))];\n        for (const m of uniqueMatches) {\n            // Find finding for this match to get type\n            const type = findings.find(f => f.match === m)?.type || 'PII';\n\n            // Escape match for regex replacement\n            const escaped = m.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n            cleanText = cleanText.replace(new RegExp(escaped, 'g'), `[${type}_REDACTED]`);\n        }\n    }\n\n    const status = isClean ? 'safe' : (mode === 'warn' ? 'warning' : 'blocked');\n\n    return {\n        hasPII: !isClean,\n        status,\n        redactedText: cleanText,\n        findings\n    };\n}\n", "import { scanPII } from './security/PII';\nimport { scanInjection } from './security/InjectionScanner';\nimport { scanEntropy } from './security/EntropyScanner';\nimport { PIIOption } from './types';\n\nexport interface AiGuardStreamOptions {\n    pii?: PIIOption;\n    blockOnInjection?: boolean;\n    onPIIDetected?: (result: any) => void;\n    onInjectionDetected?: (result: any) => void;\n    onEntropyDetected?: (result: any) => void;\n}\n\n/**\n * AiGuardStream\n * A TransformStream that scans and sanitizes chunks of text in real-time.\n * Usage: fetch(...).then(r => r.body.pipeThrough(new AiGuardStream(...)))\n */\nexport class AiGuardStream extends TransformStream {\n    constructor(options: AiGuardStreamOptions = {}) {\n        const textDecoder = new TextDecoder();\n        const textEncoder = new TextEncoder();\n\n        super({\n            transform(chunk, controller) {\n                // Decode chunk\n                let text = typeof chunk === 'string' ? chunk : textDecoder.decode(chunk, { stream: true });\n\n                // 1. Injection Check\n                const injection = scanInjection(text);\n                if (injection.isDetected) {\n                    if (options.onInjectionDetected) options.onInjectionDetected(injection);\n\n                    if (options.blockOnInjection) {\n                        controller.error(new Error(`Security Block: ${injection.reason}`));\n                        return;\n                    }\n                }\n\n                // 2. Entropy Check\n                const entropy = scanEntropy(text);\n                if (entropy.length > 0) {\n                    if (options.onEntropyDetected) options.onEntropyDetected(entropy);\n                }\n\n                // 3. PII Redaction\n                const piiResult = scanPII(text, options.pii);\n                if (piiResult.hasPII) {\n                    if (options.onPIIDetected) options.onPIIDetected(piiResult);\n                    // Enqueue redacted text\n                    controller.enqueue(textEncoder.encode(piiResult.redactedText));\n                } else {\n                    // Enqueue original\n                    controller.enqueue(textEncoder.encode(text));\n                }\n            }\n        });\n    }\n}\n", "/**\n * repair.js\n * Stack-Based Finite State Machine for JSON repair.\n * \n * Takes broken streaming JSON and auto-closes it.\n * O(N). Fast. Deterministic.\n * \n * v1.2.0: Added extractJSON for reasoning models (DeepSeek, o1)\n * v1.3.0: Added Transparent Mode (Patches & IsPartial)\n */\n\n/**\n * Strips markdown code blocks (```json ... ```) from the string.\n * Handles partial streams where the closing ``` hasn't arrived yet.\n */\nexport function stripMarkdown(text) {\n  if (!text) return \"\";\n  let clean = text.trim();\n\n  // Handle \"```javascript\", \"```js\", \"```json\", or just \"```\"\n  clean = clean.replace(/^```[a-zA-Z]*\\s*/, \"\");\n\n  // Remove closing ``` if at the very end\n  clean = clean.replace(/\\s*```$/, \"\");\n\n  return clean;\n}\n\n/**\n * Extracts JSON from mixed content (reasoning traces, markdown, prose).\n * \n * Handles:\n * - <think>...</think> reasoning traces (DeepSeek-R1, o1)\n * - Markdown code blocks ```json ... ```\n * - Prose before/after JSON: \"Here is your data: {...} Let me know!\"\n * - Multiple JSON blocks (returns last complete one, or last partial)\n * \n * @param {string} text - Raw LLM output with mixed content\n * @param {object} options\n * @param {boolean} options.last - Return last JSON block instead of first (default: true)\n * @returns {string} - Extracted JSON string (may still need repair)\n */\nexport function extractJSON(text, options = {}) {\n  if (!text) return \"\";\n\n  const { last = true } = options;\n\n  let clean = text;\n\n  // Step 1: Remove <think>...</think> reasoning traces (DeepSeek-R1, o1-style)\n  // Handle both complete and partial (unclosed) think tags\n  clean = clean.replace(/<think>[\\s\\S]*?<\\/think>/gi, ''); // Lazy match\n  clean = clean.replace(/<think>[\\s\\S]*$/gi, ''); // Partial unclosed tag\n  clean = clean.replace(/<\\/th$/gi, ''); // Swallow partial closing tag specific to \"Start of </think>\" edge case\n\n  // Step 2: Extract from markdown code blocks first (highest priority)\n  const codeBlockRegex = /```(?:json|json5|javascript|js)?\\s*([\\s\\S]*?)(?:```|$)/gi;\n  const codeBlocks = [];\n  let match;\n\n  while ((match = codeBlockRegex.exec(clean)) !== null) {\n    const content = match[1].trim();\n    if (content && (content.startsWith('{') || content.startsWith('['))) {\n      codeBlocks.push(content);\n    }\n  }\n\n  if (codeBlocks.length > 0) {\n    return last ? codeBlocks[codeBlocks.length - 1] : codeBlocks[0];\n  }\n\n  // Step 3: No code blocks - find raw JSON in the text\n  // Look for { or [ that starts a JSON structure\n  const jsonCandidates = [];\n  let depth = 0;\n  let start = -1;\n  let inString = false;\n  let escaped = false;\n\n  for (let i = 0; i < clean.length; i++) {\n    const char = clean[i];\n\n    if (escaped) {\n      escaped = false;\n      continue;\n    }\n\n    if (char === '\\\\' && inString) {\n      escaped = true;\n      continue;\n    }\n\n    if (char === '\"' && !escaped) {\n      inString = !inString;\n      continue;\n    }\n\n    if (inString) continue;\n\n    if (char === '{' || char === '[') {\n      if (depth === 0) start = i;\n      depth++;\n    } else if (char === '}' || char === ']') {\n      depth--;\n      if (depth === 0 && start !== -1) {\n        // Found complete JSON block\n        jsonCandidates.push(clean.slice(start, i + 1));\n        start = -1;\n      }\n    }\n  }\n\n  // Handle incomplete JSON (stream still coming)\n  if (start !== -1 && depth > 0) {\n    jsonCandidates.push(clean.slice(start));\n  }\n\n  if (jsonCandidates.length > 0) {\n    return last ? jsonCandidates[jsonCandidates.length - 1] : jsonCandidates[0];\n  }\n\n  // Step 4: Fallback - try to find anything that looks like JSON start\n  const firstBrace = clean.indexOf('{');\n  const firstBracket = clean.indexOf('[');\n\n  if (firstBrace === -1 && firstBracket === -1) {\n    return clean.trim(); // No JSON found, return as-is for repair to handle\n  }\n\n  const jsonStart = firstBrace === -1 ? firstBracket :\n    firstBracket === -1 ? firstBrace :\n      Math.min(firstBrace, firstBracket);\n\n  return clean.slice(jsonStart).trim();\n}\n\n/**\n * Repairs a broken JSON string by auto-closing brackets and quotes.\n * Now returns a transparent repair report.\n * \n * @param {string} raw - The broken JSON string from a stream.\n * @param {object} options\n * @param {boolean} options.extract - Run extractJSON first (for reasoning models)\n * @returns {object} - { fixed, data, isPartial, patches }\n */\nexport function repairJSON(raw, options = {}) {\n  const { extract = false } = options;\n\n  // Pre-process: Extract JSON if requested (for reasoning models)\n  let text = extract ? extractJSON(raw) : stripMarkdown(raw);\n\n  // Empty check\n  if (!text || !text.trim()) {\n    return {\n      fixed: \"{}\",\n      data: {},\n      isPartial: false,\n      patches: []\n    };\n  }\n\n  let result = text.trim();\n  const patches = [];\n  let isPartial = false;\n\n  // State machine\n  const stack = [];\n  let inString = false;\n  let escaped = false;\n\n  for (let i = 0; i < result.length; i++) {\n    const char = result[i];\n\n    if (escaped) {\n      escaped = false;\n      continue;\n    }\n\n    if (char === '\\\\' && inString) {\n      escaped = true;\n      continue;\n    }\n\n    if (char === '\"' && !escaped) {\n      inString = !inString;\n      if (inString) {\n        stack.push('\"');\n      } else {\n        if (stack.length > 0 && stack[stack.length - 1] === '\"') {\n          stack.pop();\n        }\n      }\n      continue;\n    }\n\n    if (inString) continue;\n\n    if (char === '{') {\n      stack.push('{');\n    } else if (char === '[') {\n      stack.push('[');\n    } else if (char === '}') {\n      if (stack.length > 0 && stack[stack.length - 1] === '{') {\n        stack.pop();\n      }\n    } else if (char === ']') {\n      if (stack.length > 0 && stack[stack.length - 1] === '[') {\n        stack.pop();\n      }\n    }\n  }\n\n  // Auto-close: First close any open string\n  if (inString) {\n    patches.push({ type: 'unclosed_string', index: result.length });\n    result += '\"';\n    isPartial = true;\n    if (stack.length > 0 && stack[stack.length - 1] === '\"') {\n      stack.pop();\n    }\n  }\n\n  // Handle trailing comma before closing\n  if (/,\\s*$/.test(result)) {\n    const match = result.match(/,\\s*$/);\n    patches.push({ type: 'trailing_comma', index: match.index });\n    result = result.replace(/,\\s*$/, '');\n    isPartial = true;\n  }\n\n  // Close remaining brackets in reverse order\n  while (stack.length > 0) {\n    const open = stack.pop();\n    if (open === '{') {\n      patches.push({ type: 'missing_brace', index: result.length });\n      result += '}';\n      isPartial = true;\n    } else if (open === '[') {\n      patches.push({ type: 'missing_brace', index: result.length });\n      result += ']';\n      isPartial = true;\n    }\n  }\n\n  // Attempt to parse\n  let data = null;\n  try {\n    data = JSON.parse(result);\n  } catch (err) {\n    // If it still fails, data remains null\n  }\n\n  return {\n    fixed: result,\n    data,\n    isPartial,\n    patches\n  };\n}\n", "/**\n * scanner.js\n * The logic for detecting PII and secrets.\n * \n * Rules:\n * 1. Fail fast.\n * 2. Deterministic matching.\n * \n * v1.2.0: Added allow-lists and custom rules\n * v1.3.0: Added 'warn' and 'silent' modes (DLP Pivot)\n */\n\nconst PATTERNS = {\n  // Credit Card - groups of 4 digits separated by spaces or dashes\n  CREDIT_CARD: /\\b(?:\\d{4}[ -]?){3}\\d{4}\\b/,\n\n  // Standard Email\n  EMAIL: /\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}\\b/,\n\n  // Generic \"Secret Key\" patterns (sk-, ghp-, etc)\n  API_KEY: /\\b(sk-[a-zA-Z0-9]{20,}|ghp_[a-zA-Z0-9]{36}|gho_[a-zA-Z0-9]{36})\\b/,\n\n  // US SSN (Area-Group-Serial)\n  SSN: /\\b\\d{3}-\\d{2}-\\d{4}\\b/,\n\n  // IP Address (IPv4)\n  IPV4: /\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\b/,\n\n  // AWS Access Key ID\n  AWS_KEY: /\\b(AKIA[0-9A-Z]{16})\\b/,\n\n  // JWT Token\n  JWT: /\\beyJ[a-zA-Z0-9_-]*\\.eyJ[a-zA-Z0-9_-]*\\.[a-zA-Z0-9_-]*\\b/\n};\n\n/**\n * Scans text for specific PII types.\n * @param {string} text - The raw input.\n * @param {object|string[]} options - Config object or rules array (legacy)\n * @param {boolean} legacyRedact - Legacy redact arg\n * @param {array} legacyAllow - Legacy allow list\n * @param {array} legacyCustom - Legacy custom rules\n */\nexport function scanText(text, options = {}, legacyRedact = false, legacyAllow = [], legacyCustom = []) {\n  // Normalize options (v1.3.0 supports object config, v1.2.0 was positional)\n  let config = {};\n  if (Array.isArray(options)) {\n    config = {\n      rules: options,\n      redact: legacyRedact,\n      allow: legacyAllow,\n      customRules: legacyCustom,\n      mode: 'block' // default\n    };\n  } else {\n    config = {\n      rules: [],\n      redact: false,\n      allow: [],\n      customRules: [],\n      mode: 'block',\n      ...options\n    };\n  }\n\n  const { rules = [], redact = false, allow = [], customRules = [], mode = 'block' } = config;\n\n  let cleanText = text;\n  const findings = [];\n  let isClean = true;\n\n  // Build combined pattern map (built-in + custom)\n  const allPatterns = { ...PATTERNS };\n  for (const rule of customRules) {\n    if (rule.name && rule.pattern) {\n      allPatterns[rule.name] = rule.pattern;\n    }\n  }\n\n  // Default to all rules if none specified\n  const rulesToCheck = rules.length > 0\n    ? rules\n    : Object.keys(allPatterns);\n\n  // Pre-compile allow-list patterns\n  const allowPatterns = allow.map(p =>\n    typeof p === 'string' ? new RegExp(p) : p\n  );\n\n  for (const rule of rulesToCheck) {\n    const regex = allPatterns[rule];\n    if (!regex) continue;\n\n    // Create global regex for matching\n    const globalRegex = new RegExp(regex.source, 'g');\n    const matches = text.match(globalRegex);\n\n    if (matches && matches.length > 0) {\n      // Filter out allowed matches\n      const filteredMatches = matches.filter(match =>\n        !allowPatterns.some(allow => allow.test(match))\n      );\n\n      if (filteredMatches.length > 0) {\n        isClean = false;\n        findings.push({ type: rule, matches: filteredMatches });\n      }\n    }\n  }\n\n  // Apply redaction if needed\n  // We redact if: \n  // 1. redact is explicitly true\n  // 2. OR mode is 'block' (default safe behavior)\n  if (!isClean && (redact || mode === 'block')) {\n    for (const finding of findings) {\n      for (const match of finding.matches) {\n        cleanText = cleanText.replace(match, `[${finding.type}_REDACTED]`);\n      }\n    }\n  }\n\n  // The Pivot Logic\n  let status = isClean ? 'safe' : 'blocked';\n  if (!isClean && mode === 'warn') {\n    status = 'warning';\n  }\n\n  // Safe to proceed?\n  // Block mode: only safe if clean.\n  // Warn/Silent mode: always safe (pass-through).\n  const isSafe = isClean || mode === 'warn' || mode === 'silent';\n\n  return {\n    safe: isSafe,\n    status,\n    findings,\n    text: cleanText\n  };\n}\n", "/**\n * registry.js - The \"Driver\" System\n * Allows users to register model-specific profiles (e.g. DeepSeek, Claude)\n * so the core knows how to extract JSON from their unique noise.\n */\n\nconst PROFILES = new Map();\n\n// Default Profile: Standard JSON handling\nconst DEFAULT_PROFILE = {\n    extractors: [\n        // Standard Markdown Code Block Stripper\n        (text) => text.replace(/^```[a-z]*\\s*/i, \"\").replace(/\\s*```$/, \"\"),\n        // DeepSeek/Reasoning Model <think> Stripper (Handles unclosed tags)\n        (text) => text\n            .replace(/<think>[\\s\\S]*?<\\/think>/gi, \"\")\n            .replace(/<think>[\\s\\S]*$/gi, \"\")\n            .replace(/<\\/th$/gi, \"\")\n    ]\n};\n\nPROFILES.set('default', DEFAULT_PROFILE);\n\nexport function registerProfile(name, config) {\n    PROFILES.set(name, config);\n}\n\nexport function getProfile(name) {\n    return PROFILES.get(name) || PROFILES.get('default');\n}\n", "import { z } from 'zod';\n\n/**\n * SchemaEngine\n * Handles advanced Zod operations for streaming data:\n * 1. Deep Partial Validation (for incomplete streams)\n * 2. Hallucination Stripping (Security)\n * 3. Skeleton Generation (Zero-latency UI)\n */\nexport class SchemaEngine {\n    constructor(schema) {\n        if (!schema) throw new Error(\"SchemaEngine requires a Zod schema\");\n        this.schema = schema;\n        // Cache the partial schema for performance\n        this.partialSchema = this._createDeepPartial(schema);\n    }\n\n    /**\n     * Creates a 'relaxed' schema that allows missing fields/partial data\n     * but enforces the structure that IS present.\n     */\n    _createDeepPartial(schema) {\n        if (typeof schema.deepPartial === 'function') {\n            // Zod's native deepPartial handles objects/arrays recursively\n            // and preserves the 'strip' behavior for unknown keys.\n            return schema.deepPartial();\n        }\n        // Fallback for non-nested schemas or older Zod versions\n        if (typeof schema.partial === 'function') {\n            return schema.partial();\n        }\n        return schema;\n    }\n\n    /**\n     * Validates partial data and strips unknown keys (hallucinations).\n     * @param {any} data - The partial JSON from the repair stream\n     * @returns {object} - { data, isValid, errors }\n     */\n    validate(data) {\n        try {\n            // safeParse with the partial schema will:\n            // 1. Allow missing keys (due to deepPartial)\n            // 2. Strip unknown keys (default Zod behavior)\n            // 3. Validate types of present keys\n            const result = this.partialSchema.safeParse(data);\n\n            if (result.success) {\n                return {\n                    data: result.data,\n                    isValid: true,\n                    errors: []\n                };\n            } else {\n                return {\n                    data: data, // Return raw data if validation fails completely\n                    isValid: false,\n                    errors: result.error.errors\n                };\n            }\n        } catch (err) {\n            return {\n                data: data,\n                isValid: false,\n                errors: [{ message: err.message }]\n            };\n        }\n    }\n\n    /**\n     * Generates a structural skeleton (stub) from the schema.\n     * Used for optimistic UI before the first token arrives.\n     */\n    generateSkeleton() {\n        return this._generateStub(this.schema);\n    }\n\n    _generateStub(schema) {\n        if (!schema) return null;\n\n        // Unwrap optional/nullable/default\n        if (schema instanceof z.ZodOptional || schema instanceof z.ZodNullable) {\n            // For stubs, we might want null or the underlying type's stub?\n            // Usually matching the structure is better, even if null is allowed.\n            return this._generateStub(schema.unwrap?.() || schema._def.innerType);\n        }\n        if (schema instanceof z.ZodDefault) {\n            return this._generateStub(schema.removeDefault());\n        }\n        if (schema instanceof z.ZodEffects) {\n            return this._generateStub(schema._def.schema);\n        }\n\n        // Handle primitives\n        if (schema instanceof z.ZodString) return \"\";\n        if (schema instanceof z.ZodNumber) return 0;\n        if (schema instanceof z.ZodBoolean) return false;\n        if (schema instanceof z.ZodArray) return [];\n\n        // Handle Objects\n        if (schema instanceof z.ZodObject) {\n            const shape = schema.shape;\n            const stub = {};\n            for (const key in shape) {\n                stub[key] = this._generateStub(shape[key]);\n            }\n            return stub;\n        }\n\n        return null;\n    }\n}\n"],
  "mappings": "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",
  "names": ["PATTERNS", "allow"]
}
